# -*- coding: utf-8 -*-
"""G4_and_palindromes_Triplexes.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1w-n0XK2wQUTiPvKILApvM6JzHO30hHi0
"""

!pip install biopython

"""**revised version of the code**"""

import psutil
print(f"Total RAM: {psutil.virtual_memory().total / (1024 ** 3)} GB")

import os

def main(genome_file, output_file_prefix):
    """
    Search for G-quadruplex motifs in the human genome and save their genomic coordinates to individual output files.
    """
    # Ensure the output directory exists
    output_dir = os.path.dirname(output_file_prefix)
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    with open(genome_file, 'r') as infile:
        for record in SeqIO.parse(infile, "fasta"):
            output_file = f"{output_file_prefix}_{record.id}.bed"
            with open(output_file, 'w') as outfile:
                print(f"Processing {record.id}...")

                # Search in plus strand
                g4_motifs_plus = find_g4_motifs(str(record.seq))
                for motif, start, end in g4_motifs_plus:
                    outfile.write(f"Found G4 motif on + strand in {record.id} at coordinates {start}-{end}: {motif}\n")

                # Search in minus strand (reverse complement)
                reverse_seq = str(record.seq.reverse_complement())
                g4_motifs_minus = find_g4_motifs(reverse_seq)
                seq_length = len(record.seq)
                for motif, start, end in g4_motifs_minus:
                    # Adjust coordinates to original sequence
                    adjusted_start = seq_length - end
                    adjusted_end = seq_length - start
                    outfile.write(f"Found G4 motif on - strand in {record.id} at coordinates {adjusted_start}-{adjusted_end}: {motif}\n")

            # Memory monitoring after each chromosome
            memory_info = psutil.virtual_memory()
            print(f"Memory Usage after processing {record.id}: {memory_info.percent}% used")

if __name__ == "__main__":
    # Replace with your input and desired output file paths
    main("/content/drive/MyDrive/hg19/sequence/hg19.fa", "/content/drive/MyDrive/hg19/sequence/hg19_G4_motifs")

import subprocess
import numpy as np

# Parameters
iterations = 1000
observed_count = 242
g4_file = "/content/g4_output.bed"
alu_file = "/content/Alu_hg19.bed"
genome_file = "/content/hg19.chrom.sizes"
shuffled_file = "/content/hgg4_shuffled.bed"

# List to store overlap counts from shuffling
shuffle_counts = []

# Perform shuffling and intersection for multiple iterations
for i in range(iterations):
    # Shuffle G4 motifs
    shuffle_command = f"bedtools shuffle -i {g4_file} -g {genome_file} > {shuffled_file}"
    subprocess.run(shuffle_command, shell=True, check=True)

    # Intersect shuffled G4 motifs with Alu elements
    intersect_command = f"bedtools intersect -a {shuffled_file} -b {alu_file} -wa -wb | grep -c chr"
    result = subprocess.run(intersect_command, shell=True, check=True, capture_output=True, text=True)
    shuffle_counts.append(int(result.stdout.strip()))

# Calculate the mean and standard deviation of the shuffled counts
mean_shuffled = np.mean(shuffle_counts)
std_shuffled = np.std(shuffle_counts)

# Calculate the p-value
p_value = sum(1 for count in shuffle_counts if count <= observed_count) / iterations

# Calculate the Z-score
z_score = (observed_count - mean_shuffled) / std_shuffled

# Print results
print(f"Observed Overlap Count: {observed_count}")
print(f"Mean of Shuffled Overlap Counts: {mean_shuffled}")
print(f"Standard Deviation of Shuffled Overlap Counts: {std_shuffled}")
print(f"P-value: {p_value}")
print(f"Z-score: {z_score}")

import re
import logging

# Configure logging to write errors to a file
logging.basicConfig(filename='errors.log', level=logging.ERROR)

def convert_format(input_file, output_file):
    """
    Convert the input format to the desired output format using regular expressions.
    """
    # Regex pattern to extract chromosome, start, end coordinates, and motif
    pattern = re.compile(r"Found G4 motif in (.+?) at coordinates (\d+)-(\d+): (.+)")

    with open(input_file, 'r') as infile, open(output_file, 'w') as outfile:
        for line in infile:
            match = pattern.match(line)
            if match:
                # Extract the matched groups
                chromosome, start_coordinate, end_coordinate, motif = match.groups()

                # Write the result to the output file in tab-delimited format
                outfile.write(f"{chromosome}\t{start_coordinate}\t{end_coordinate}\t{motif}\n")
            else:
                # Log the error for lines that do not match the expected pattern
                logging.error(f"Error processing line: {line.strip()}")

if __name__ == "__main__":
    # Specify your input and output file paths
    input_file = "/content/drive/MyDrive/hg19_G4.bed"
    output_file = "/content/drive/MyDrive/G4_hg19.bed"

    # Convert the input format to the output format
    convert_format(input_file, output_file)

from Bio import SeqIO
import os

# Define your input file path and output directory
# Define your input file path and output directory
input_file_path = '/content/drive/MyDrive/palindrome/hg19.fa'
output_dir = '/content/drive/MyDrive/palindrome/genome_analysis_results'

# Ensure the output directory exists
os.makedirs(output_dir, exist_ok=True)

# Precompute the reverse complements for all nucleotides
complements = str.maketrans('ATCGN', 'TAGCN')

def reverse_complement(seq):
    """Return the reverse complement of the sequence."""
    return seq.translate(complements)[::-1]

def is_palindrome(seq):
    """Check if the sequence is a palindrome."""
    rc_seq = reverse_complement(seq)
    return seq == rc_seq

# Load sequences from the hg19.fasta file
genome_sequences = [(record.id, str(record.seq).upper()) for record in SeqIO.parse(input_file_path, "fasta")]

for chr_name, sequence in genome_sequences:
    # Define file paths for output
    pal_file_path = os.path.join(output_dir, f"{chr_name}_palindromes.bed")

    with open(pal_file_path, "w") as pal_file:
        # Iterate over the sequence to check for palindromes
        for i in range(len(sequence) - 9):  # For 10bp palindromes
            segment = sequence[i:i+10]
            # Skip segments with 'N'
            if 'N' in segment:
                continue
            # Check for a palindrome
            if is_palindrome(segment):
                pal_file.write(f"{chr_name}\t{i}\t{i+10}\tpalindrome\n")

# Debugging: print out the first few lines to verify the output
with open(pal_file_path, 'r') as file:
    lines = file.readlines()
    for line in lines[:10]:  # Print the first 10 lines
        print(line.strip())

from Bio import SeqIO

def extract_sequence(filepath, chrom, start, end):
    for record in SeqIO.parse(filepath, "fasta"):
        if record.id == chrom:
            return str(record.seq[start:end])
    return None

# Use this function with the coordinates from your BED file
fasta_file_path = '/content/drive/MyDrive/palindrome/hg19.fa'  # Replace with the path to your FASTA file
chromosome = 'chr1'
start_pos = 47006042  # Replace with your actual start position
end_pos = 47006052  # Replace with your actual end position

sequence = extract_sequence(fasta_file_path, chromosome, start_pos - 1, end_pos)  # -1 because Python is 0-based
print(sequence)

from Bio import SeqIO
import os
from multiprocessing import Pool

# Precompute the reverse complements for all nucleotides
complements = str.maketrans('ATCGN', 'TAGCN')

def reverse_complement(seq):
    """Return the reverse complement of the sequence."""
    return seq.translate(complements)[::-1]

def is_palindrome(seq):
    """Check if the sequence is a palindrome."""
    rc_seq = reverse_complement(seq)
    return seq == rc_seq

def is_quasi_palindrome(sequence, allowed_mismatches=2):
    """Check if the sequence is a quasi-palindrome."""
    rc_sequence = reverse_complement(sequence)
    mismatches = sum(1 for a, b in zip(sequence, rc_sequence) if a != b)
    return mismatches <= allowed_mismatches

def has_palindrome_spacer(sequence, min_spacer=1, max_spacer=5):
    """Check if the sequence has a palindrome with a spacer."""
    for spacer_length in range(min_spacer, max_spacer + 1):
        part1 = sequence[:-(spacer_length)]
        part2 = sequence[spacer_length:]
        spacer = sequence[-(spacer_length):]  # Extract the spacer sequence
        if is_palindrome(part1) and is_palindrome(part2):
            # Ensure the spacer is not complementary to any part of the palindromic sequences
            if not any(base in spacer for base in 'ATCG'):
                return True
    return False

def process_chunk(data):
    chrom, start, chunk_size, sequence, output_dir = data

    results = {"palindromes": [], "quasi_palindromes": [], "spacers": []}

    # Adjust the length as needed (check for lengths of 8, 9, and 10)
    for length in range(8, 11):  # This will check for lengths 8, 9, and 10
        for i in range(0, len(sequence) - length + 1):
            segment = sequence[i:i+length]
            if is_palindrome(segment):
                results["palindromes"].append(f"{chrom}\t{start+i}\t{start+i+length}\tpalindrome\n")
            elif is_quasi_palindrome(segment):
                results["quasi_palindromes"].append(f"{chrom}\t{start+i}\t{start+i+length}\tquasi-palindrome\n")
            elif has_palindrome_spacer(segment):
                results["spacers"].append(f"{chrom}\t{start+i}\t{start+i+length}\tpalindrome_with_spacer\n")

    # Write to files
    for result_type, data_list in results.items():
        if data_list:
            with open(os.path.join(output_dir, f"{chrom}_{result_type}.bed"), "a") as f:
                f.writelines(data_list)

def main():
    input_file_path = '/content/drive/MyDrive/palindrome/hg19.fa'  # Adjust the path to your hg19.fa file
    output_dir = '/content/drive/MyDrive/palindrome/genome_analysis_results'  # Adjust the path to your output directory
    chunk_size = 10000  # Decreased chunk size
    process_limit = 4  # Limit the number of processes

    # Ensure the output directory exists
    os.makedirs(output_dir, exist_ok=True)

    # Index the genome
    genome_dict = SeqIO.index(input_file_path, "fasta")

    # Create tasks for multiprocessing
    tasks = []
    for chrom in genome_dict:
        chrom_seq = str(genome_dict[chrom].seq)  # Convert the sequence to a string here
        for start in range(0, len(chrom_seq), chunk_size):
            chunk_seq = chrom_seq[start:start+chunk_size]  # Get the chunk sequence here
            tasks.append((chrom, start, chunk_size, chunk_seq, output_dir))

    # Process in parallel with limited processes
    with Pool(process_limit) as pool:
        pool.map(process_chunk, tasks)

if __name__ == "__main__":
    main()

from Bio import SeqIO
import os
from multiprocessing import Pool

# Precompute the reverse complements for all nucleotides
complements = str.maketrans('ATCGN', 'TAGCN')

def reverse_complement(seq):
    """Return the reverse complement of the sequence."""
    return seq.translate(complements)[::-1]

def is_palindrome(seq):
    """Check if the sequence is a palindrome."""
    rc_seq = reverse_complement(seq)
    return seq == rc_seq

def is_quasi_palindrome(sequence, allowed_mismatches=2):
    """Check if the sequence is a quasi-palindrome."""
    rc_sequence = reverse_complement(sequence)
    mismatches = sum(1 for a, b in zip(sequence, rc_sequence) if a != b)
    return mismatches <= allowed_mismatches

def has_palindrome_spacer(sequence, min_spacer=1, max_spacer=5):
    """Check if the sequence has a palindrome with a spacer."""
    for spacer_length in range(min_spacer, max_spacer + 1):
        part1 = sequence[:-(spacer_length)]
        part2 = sequence[spacer_length:]
        spacer = sequence[-(spacer_length):]  # Extract the spacer sequence
        if is_palindrome(part1) and is_palindrome(part2):
            # Ensure the spacer is not complementary to any part of the palindromic sequences
            if not any(base in spacer for base in 'ATCG'):
                return True
    return False

def process_chunk(data):
    chrom, start, chunk_size, sequence, output_dir = data

    results = {"palindromes": [], "quasi_palindromes": [], "spacers": []}

    # Adjust the length as needed (check for lengths of 8, 9, and 10)
    for length in range(8, 11):  # This will check for lengths 8, 9, and 10
        for i in range(0, len(sequence) - length + 1):
            segment = sequence[i:i+length]
            if is_palindrome(segment):
                results["palindromes"].append(f"{chrom}\t{start+i}\t{start+i+length}\tpalindrome\n")
            elif is_quasi_palindrome(segment):
                results["quasi_palindromes"].append(f"{chrom}\t{start+i}\t{start+i+length}\tquasi-palindrome\n")
            elif has_palindrome_spacer(segment):
                results["spacers"].append(f"{chrom}\t{start+i}\t{start+i+length}\tpalindrome_with_spacer\n")

    # Write to files
    for result_type, data_list in results.items():
        if data_list:
            with open(os.path.join(output_dir, f"{chrom}_{result_type}.bed"), "a") as f:
                f.writelines(data_list)


def main():
    input_file_path = '/content/drive/MyDrive/palindrome/hg19.fa'  # Adjust the path to your hg19.fa file
    output_dir = '/content/drive/MyDrive/palindrome/genome_analysis_results'  # Adjust the path to your output directory
    chunk_size = 10000  # Decreased chunk size
    process_limit = 4  # Limit the number of processes

    # Ensure the output directory exists
    os.makedirs(output_dir, exist_ok=True)

    # Index the genome
    genome_dict = SeqIO.index(input_file_path, "fasta")

    # Create tasks for multiprocessing
    tasks = []
    for chrom in genome_dict:
        if chrom != 'chr1':  # Skip if not chromosome 1
            continue
        chrom_seq = str(genome_dict[chrom].seq)  # Convert the sequence to a string here
        for start in range(0, len(chrom_seq), chunk_size):
            chunk_seq = chrom_seq[start:start+chunk_size]  # Get the chunk sequence here
            tasks.append((chrom, start, chunk_size, chunk_seq, output_dir))

    # Process in parallel with limited processes
    with Pool(process_limit) as pool:
        pool.map(process_chunk, tasks)

if __name__ == "__main__":
    main()

import glob
from Bio import SeqIO
from Bio.Seq import Seq
import os

# Function to check if a sequence is a palindrome
def is_palindrome(seq):
    return seq == str(Seq(seq).reverse_complement())

# Function to check for a quasi-palindrome
def is_quasi_palindrome(seq, allowed_mismatches=2):
    rc_seq = str(Seq(seq).reverse_complement())
    mismatches = sum(1 for a, b in zip(seq, rc_seq) if a != b)
    return mismatches <= allowed_mismatches

# Function to check for a palindrome with a spacer
def has_palindrome_spacer(seq, min_spacer=1, max_spacer=5):
    for spacer_length in range(min_spacer, max_spacer + 1):
        part1 = seq[:-(spacer_length)]
        part2 = seq[spacer_length:]
        if is_palindrome(part1) and is_palindrome(part2):
            return True
    return False

# Define the checks for each type of palindrome
palindrome_checks = {
    "palindromes": is_palindrome,
    "quasi_palindromes": is_quasi_palindrome,
    "spacers": has_palindrome_spacer
}

# Define the chromosome names
def correct_chromosome_name(chrom):
    if not chrom.startswith('chr'):
        chrom = 'chr' + chrom.lstrip('ch')
    return chrom

def correct_bed_line(parts):
    chrom = parts[0]
    for part in parts[1:]:
        if part.isdigit():
            start = int(part)
            break
    for part in reversed(parts):
        if part.isdigit():
            end = int(part)
            break
    return chrom, start, end


def process_chromosome_bed_file(chromosome_fasta_path, input_bed_dir, output_bed_dir, chromosome_name):
    # Load the chromosome sequence
    chromosome_seq_record = SeqIO.read(chromosome_fasta_path, "fasta")
    chromosome_seq = str(chromosome_seq_record.seq).upper()

    # Process each type of palindrome
    for palindrome_type, check_function in palindrome_checks.items():
        bed_files = glob.glob(os.path.join(input_bed_dir, f'{chromosome_name}_*_{palindrome_type}.bed'))

        # Debug: Print the number of files found for the current palindrome type
        print(f"Found {len(bed_files)} files for {chromosome_name} with {palindrome_type}")

        for input_bed_path in bed_files:
            print(f"Processing file: {input_bed_path}")  # Debug: Print the current file being processed

            output_file_path = os.path.join(output_bed_dir, f"filtered_{os.path.basename(input_bed_path)}")

            with open(input_bed_path, 'r') as bed_file, \
                 open(output_file_path, 'w') as output_file:

                for line in bed_file:
                    parts = line.strip().split('\t')
                    if len(parts) < 3:
                        # Debug: Print out invalid line format
                        print(f"Invalid line format (not enough fields): {line.strip()}")
                        continue  # Not enough data to process

                    try:
                        chrom, start, end = correct_bed_line(parts)
                    except ValueError:
                        # Debug: Print out line with value error
                        print(f"Invalid line format: {line.strip()}")
                        continue

                    seq = chromosome_seq[start:end]
                    if check_function(seq) and 'N' not in seq:
                        output_file.write(f"{chrom}\t{start}\t{end}\t{seq}\n")
                        # Debug: Print out successful write
                        print(f"Writing to file: {chrom}\t{start}\t{end}\t{seq}")
                    else:
                        # Debug: Print out skipped sequences
                        print(f"Skipping invalid or masked sequence: {chrom}\t{start}\t{end}\t{seq}")

# Example usage for a single chromosome:
process_chromosome_bed_file(
    chromosome_fasta_path='/content/drive/MyDrive/palindrome/chr1.fa',
    input_bed_dir='/content/drive/MyDrive/palindrome/genome_analysis_results',
    output_bed_dir='/content/drive/MyDrive/palindrome/final_results',
    chromosome_name='chr1'
)

"""**checking the code **"""

import glob
from Bio import SeqIO
import os

# Function to check if a sequence is a palindrome
def reverse_complement(seq):
    complement = str.maketrans('ATCGN', 'TAGCN')
    return seq.translate(complement)[::-1]

def is_palindrome(seq):
    return seq == reverse_complement(seq)

# Function to check for a quasi-palindrome
def is_quasi_palindrome(seq, allowed_mismatches=2):
    rc_seq = reverse_complement(seq)
    mismatches = sum(1 for a, b in zip(seq, rc_seq) if a != b)
    return mismatches <= allowed_mismatches

# Corrected implementation of has_palindrome_spacer function
def has_palindrome_spacer(seq, min_spacer=1, max_spacer=5):
    for i in range(len(seq)):
        for j in range(i + min_spacer, min(len(seq), i + max_spacer) + 1):
            part1 = seq[:i]
            part2 = seq[j:]
            if part1 and part2 and is_palindrome(part1) and is_palindrome(part2):
                return True
    return False

# Define the checks for each type of palindrome
palindrome_checks = {
    "palindromes": is_palindrome,
    "quasi_palindromes": is_quasi_palindrome,
    "spacers": has_palindrome_spacer
}

def correct_bed_line(parts):
    chrom = parts[0]
    for part in parts[1:]:
        if part.isdigit():
            start = int(part)
            break
    for part in reversed(parts):
        if part.isdigit():
            end = int(part)
            break
    return chrom, start, end

def process_chromosome_bed_file(chromosome_fasta_path, input_bed_dir, output_bed_dir, chromosome_name):
    # Load the chromosome sequence
    chromosome_seq_record = SeqIO.read(chromosome_fasta_path, "fasta")
    chromosome_seq = str(chromosome_seq_record.seq).upper()

    # Process each type of palindrome
    for palindrome_type, check_function in palindrome_checks.items():
        bed_files = glob.glob(os.path.join(input_bed_dir, f'{chromosome_name}_*_{palindrome_type}.bed'))

        # Debug: Print the number of files found for the current palindrome type
        print(f"Found {len(bed_files)} files for {chromosome_name} with {palindrome_type}")

        for input_bed_path in bed_files:
            print(f"Processing file: {input_bed_path}")  # Debug: Print the current file being processed

            output_file_path = os.path.join(output_bed_dir, f"filtered_{os.path.basename(input_bed_path)}")

            with open(input_bed_path, 'r') as bed_file, \
                 open(output_file_path, 'w') as output_file:

                processed_count = 0
                written_count = 0

                for line in bed_file:
                    parts = line.strip().split('\t')
                    if len(parts) < 3:
                        # Debug: Print out invalid line format
                        print(f"Invalid line format (not enough fields): {line.strip()}")
                        continue  # Not enough data to process

                    try:
                        chrom, start, end = correct_bed_line(parts)
                    except ValueError:
                        # Debug: Print out line with value error
                        print(f"Invalid line format: {line.strip()}")
                        continue

                    processed_count += 1
                    seq = chromosome_seq[start:end]
                    if check_function(seq) and 'N' not in seq:
                        output_file.write(f"{chrom}\t{start}\t{end}\t{seq}\n")
                        written_count += 1
                        # Debug: Print out successful write
                        print(f"Writing to file: {chrom}\t{start}\t{end}\t{seq}")
                    else:
                        # Debug: Print out skipped sequences
                        print(f"Skipping invalid or masked sequence: {chrom}\t{start}\t{end}\t{seq}")

                # Debug: Print the count of processed and written sequences
                print(f"Processed {processed_count} sequences for {chromosome_name} with {palindrome_type}")
                print(f"Wrote {written_count} sequences to file for {chromosome_name} with {palindrome_type}")

# Example usage for a single chromosome:
process_chromosome_bed_file(
    chromosome_fasta_path='/content/drive/MyDrive/palindrome/chr1.fa',
    input_bed_dir='/content/drive/MyDrive/palindrome/genome_analysis_results',
    output_bed_dir='/content/drive/MyDrive/palindrome/final_results',
    chromosome_name='chr1'
)

!git clone https://github.com/yuuuuzhang/TriplexFPP.git

!pip install matplotlib

import matplotlib.pyplot as plt
frequencies = {
    "sb_wt": 0.82,
    "sb_K45A": 3.15,
    "sb_K47A": 3.36,
    "sb_Q40A": 4.93,
    "sb_R44A": 3.44,
    "sb_T41A": 3.02,
    "sb_V43A": 5.91,
    "sb_Y46A": 6.86
}

plt.figure(figsize=(10, 6))
plt.bar(frequencies.keys(), frequencies.values(), color='skyblue')
plt.xlabel('Samples')
plt.ylabel('Frequency of "ATATATAT" (%)')
plt.title('Frequency of "ATATATAT" Motif in Different Samples')
plt.xticks(rotation=45)
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.savefig("motif_frequencies_histogram.svg")
plt.show()
files.download('motif_frequencies_histogram.svg')

# Data for the pie chart
frequencies = {
    "sb_wt": 0.82,
    "sb_K45A": 3.15,
    "sb_K47A": 3.36,
    "sb_Q40A": 4.93,
    "sb_R44A": 3.44,
    "sb_T41A": 3.02,
    "sb_V43A": 5.91,
    "sb_Y46A": 6.86
}

labels = frequencies.keys()
sizes = frequencies.values()

# Create the pie chart
plt.figure(figsize=(8, 8))
plt.pie(sizes, labels=labels, autopct='%1.1f%%', startangle=140)
plt.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.
plt.title('Frequency of "ATATATAT" Motif in Different Samples')
plt.savefig("motif_frequencies.svg")
plt.show()

files.download('motif_frequencies.svg')

import os
print(os.getcwd())

!ls

!pip install matplotlib

import matplotlib.pyplot as plt

# Data for the overlaps
mutants = {
    "K47A": (212, 221),
    "K45A": (111, 83),
    "R44A": (131, 151),
    "T41A": (117, 123),
    "V43A": (109, 157),
    "Y46A": (136, 118),
    "Q40A": (131, 140),
    "sb_wt": (37, 16),
    "Random": (287, 251)
}

# Splitting the data for G4_HEK293_plus and G4_HEK293_minus
plus_overlaps = [plus for plus, minus in mutants.values()]
minus_overlaps = [minus for plus, minus in mutants.values()]

# Creating the histogram
fig, ax = plt.subplots(figsize=(10, 6))
x = range(len(mutants))
ax.bar(x, plus_overlaps, width=0.4, align='center', label='G4_HEK293_plus')
ax.bar(x, minus_overlaps, width=0.4, align='edge', label='G4_HEK293_minus')

# Labeling
ax.set_xticks(x)
ax.set_xticklabels(mutants.keys(), rotation=45)
ax.set_ylabel('Number of Overlaps')
ax.set_title('Overlap Frequencies with G4_HEK293')
ax.legend()

plt.show()

import re
from Bio import SeqIO
from Bio.Seq import Seq

def find_g4_motifs(sequence):
    """
    Identify potential G-quadruplex forming sequences in a given sequence and return their genomic coordinates.
    """
    print("Sequence in find_g4_motifs:", sequence)  # Debugging statement

    g4_pattern = re.compile(r'G{3,}\w{1,7}G{3,}\w{1,7}G{3,}\w{1,7}G{3,}')

    # Find all matches and their positions
    matches = [(match.group(), match.start(), match.end()) for match in g4_pattern.finditer(sequence)]
    print("Matches:", matches)  # Debugging statement

    return matches

def main(genome_file):
    """
    Search for G-quadruplex motifs in the human genome and print their genomic coordinates.
    """
    with open(genome_file, 'r') as infile:
        for record in SeqIO.parse(infile, "fasta"):
            print("Processing sequence:", record.id)
            g4_motifs = find_g4_motifs(str(record.seq))
            if g4_motifs:
                for motif, start, end in g4_motifs:
                    print(f"Found G4 motif in {record.id} at coordinates {start}-{end}: {motif}")
            else:
                print("No G4 motifs found in this sequence.")

if __name__ == "__main__":
    # Replace with your input file path
    main("/content/first_exon_ESRG.fa")

import re

def find_g4_motifs(sequence):
    # Define the regular expression pattern
    g4_pattern = re.compile(r'G{3,}')

    # Find all matches in the sequence
    matches = g4_pattern.finditer(sequence)

    # Extract and print the matches
    for match in matches:
        print("Match found at position:", match.start(), "-", match.end(), "->", match.group())

# Test the function with your sequence
sequence = "TATTACTCATCAAACCATTTGAATTTAATTGCATTCTTCAAAATTCTACAGCTACAGATTGCAGCAGAGAATACCAGGGACTCAGCCAGAGAAGAAAGTACTGTTTTTAAATAAACAGCTCCTGGCAGCTCTTTATTCTAGTCCACATTATTCAGATATCTTCTTTTTTCCTCTCTTTCTTTCCATGTGTTTGGGAAAATTTTTCCAGGATGTTTTCAGATGAGTTTGTGAACAATGGCCCTAGAGTATTCTGTTTTTTTCCCCTTGAAGCTTCTGTGACCTGAAGCATAGATTACTTTTATGCATTGGCTTGTTGCTGAGTTTATTCAATGGTGCGAAGCTGTGTTTAA...
print("Processing sequence: ")
find_g4_motifs(sequence)